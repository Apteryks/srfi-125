<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>SRFI 125: Intermediate hash tables</title>
  <style>#content > #right > .dose > .dosesingle,
#content > #center > .dose > .dosesingle
{display:none !important;}</style></head>

  <body>

<h1>Title</h1>

Intermediate hash tables

<h1>Author</h1>

John Cowan, Will Clinger

<h1>Abstract</h1>

<p>
This SRFI defines an interface to hash tables, which are widely recognized as a fundamental data structure for a wide variety of applications.  A hash table is a data structure that:
</p>
<ul><li>Is disjoint from all other types.
</li><li>Provides a mapping from objects known as <em>keys</em> to corresponding objects known as <em>values</em>.
<ul><li>Keys may be any Scheme objects in some kinds of hash tables, but are restricted in other kinds.
</li><li>Values may be any Scheme objects.
</li></ul></li><li>Has no intrinsic order for the key-value <em>associations</em> it contains.
</li><li>Provides an <em>equality predicate</em> which defines when a proposed key is the same as an existing key.  No table may contain more than one value for a given key.
</li><li>Provides a <em>hash function</em> which maps a candidate key into a non-negative exact integer.
</li><li>Supports mutation as the primary means of setting the contents of a table.
</li><li>Provides key lookup and destructive update in (expected) amortized constant time, provided a satisfactory hash function is available.
</li><li>Does not guarantee that whole-table operations work in the presence of concurrent mutation of the whole hash table (values may be safely mutated).
</li></ul><p>
In addition, procedures for use on bimaps (bidirectional hash tables) are defined.
</p>


<h1>Issues</h1>

<ul><li>Why is a bimap created by <code>make-bimap</code> required to share structure with its first argument?</li>
<li>Why are <code>bimap-forward-hash-table</code> and <code>bimap-reverse-hash-table</code> forbidden to return copies?  Copying hash tables would be cleaner, and would enable several procedures to be allowed to guard against the possibility that one of the encapsulated hash tables had been mutated despite the contract.</li>
</ul>
<h1>Rationale</h1>

<p>
Hash tables themselves don't really need defending: almost all dynamically typed languages, from awk to JavaScript to Lua to Perl to Python to Common Lisp, and including many Scheme implementations, provide them in some form as a fundamental data structure.  Therefore, what needs to be defended is not the data structure but the procedures.  This SRFI is at an intermediate level.  It supports a great many convenience procedures on top of the basic hash table interfaces provided by <a href="http://srfi.schemers.org/srfi-69/srfi-69.html">SRFI 69</a> and <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-14.html">R6RS</a>.  Nothing in it adds power to what those interfaces provide, but it does add convenience in the form of pre-debugged routines to do various common things, and even some things not so commonly done but useful.
</p>
<p>
There is no mandated support for thread safety, immutability, or weakness, though there are semi-portable hooks for specifying these features.
</p>
<p>
This specification accepts separate equality predicates and hash functions for backward compatibility, but strongly encourages the use of <a href="http://srfi.schemers.org/srfi-114/srfi-114.html">SRFI 114</a> comparators, which package a type test, an equality predicate, and a hash function into a single bundle.
</p>
<p>
Bimaps are just a convenience structure based on a pair of hash tables, one that maps keys to unique values, the other that maps the values back to their keys.  By providing mutation procedures, it becomes trivial to keep the two hash tables consistent.
</p>
<h3 id="SRFI69compatibility">SRFI 69 compatibility</h3>
<h4 id="Names">Names</h4>
<p>
This SRFI is downward compatible with SRFI 69, except that the reflective procedures <code>hash-table-equivalence-function</code> and <code>hash-table-hash-function</code> are not supported for reasons given in the next section.  Some procedures have been given new preferred names for compatibility with other SRFIs, but in all cases the SRFI 69 names have been retained as synonyms.  They appear in this SRFI in <small>small print</small>.</p>

<h4 id="Reflectionandhash-functionprocedures">Reflection and hash-function procedures</h4>
<p>
SRFI 69 provides reflective procedures that, given a hash table, returns its equality predicate and hash function, as well as procedures that expose the implementation's hash functions suitable for the equality predicates <code>eq?</code>, <code>equal?</code>, <code>string=?</code>, and <code>string-ci=?</code>.  The second of these can also be used for <code>eqv?</code>.  However, if the <code>eq?</code> hash function is not idempotent but depends on the memory address of the key, and the garbage collector moves such a key, it must also rehash every hash table containing that key.  In such implementations, the <code>hash-by-identity</code> procedure is unsafe to use outside the context of implementation-provided hash tables.
</p>
<p>
R6RS eliminates this issue by providing separate constructors for <code>eq?</code> and <code>eqv?</code> hash tables, and refusing to expose the hash functions for them.  However, this SRFI takes the radical option of exposing neither reflection nor implementation-based hash functions.  Instead, implementations are permitted to ignore user-provided hash functions in certain circumstances if they have address-based hash functions available.  They can of course be exposed by implementations as extensions, with suitable warnings against inappropriate uses.
</p>
<h3 id="R6RScompatibility">R6RS compatibility</h3>
<p>
The relatively few hash table procedures in R6RS are all available in this SRFI under somewhat different names.  The only substantive difference is that R6RS <code>hashtable-values</code> and <code>hashtable-entries</code> return vectors, whereas in this SRFI <code>hash-table-values</code> and <code>hash-table-entries</code> return lists.  This SRFI adopts SRFI 69's term <code>hash-table</code> rather than R6RS's <code>hashtable</code>, because of the universal use of "hash table" rather than "hashtable" in other languages and in technical prose generally.  Besides, the English word <em>hashtable</em> obviously means something that can be ... hashted.
</p>
<p>
In addition, the <code>hashtable-ref</code> and <code>hashtable-update!</code> of R6RS correspond to the <code>hash-table-ref/default</code> and <code>hash-table-update!/default</code> of both SRFI 69 and this SRFI.
</p>
<p>
It would be trivial to provide the R6RS names (or for that matter the SRFI 69 names) on top of this SRFI.
</p>
<h3 id="CommonLispcompatibility">Common Lisp compatibility</h3>
<p>
As usual, the Common Lisp names are completely different from the Scheme names. Common Lisp provides the following capabilities that are not in this SRFI:
</p>
<ul><li>The constructor allows specifying the rehash size and rehash threshold of the new hash table.  There are also accessors and mutators for these and for the current capacity (as opposed to size).
</li></ul><ul><li>There are hash tables based on <code>equalp</code> (which does not exist in Scheme).
</li></ul><ul><li><code>With-hash-table-iterator</code> is a hash table external iterator implemented as a local macro.
</li></ul><ul><li><code>Sxhash</code> is a stable but implementation-specific hash function for the <code>equal</code> predicate.
</li></ul><h3 id="Sources">Sources</h3>
<p>
The procedures in this SRFI are drawn primarily from SRFI 69 and R6RS.  In addition, the following sources are acknowledged:
</p>
<ul><li>The <code>hash-table-mutable?</code> procedure and the second argument of <code>hash-table-copy</code> (which allows the creation of immutable hash tables) are from R6RS, renamed in the style of this SRFI.
</li></ul><ul><li>The <code>hash-table-extend!</code>, <code>hash-table-extend/default</code>, <code>hash-table-collect</code>, <code>hash-table-&gt;alist</code>, and <code>alist-&gt;hash-table</code> procedures are from <a href="http://docs.racket-lang.org/reference/hashtables.html">Racket</a>, renamed in the style of this SRFI.
</li></ul><ul><li>The <code>hash-table-push!</code> and <code>hash-table-pop!</code> procedures are from <a href="http://practical-scheme.net/gauche/man/gauche-refe_53.html">Gauche</a>.
</li></ul><ul><li>The <code>hash-table-find</code> procedure is a modified version of <code>table-search</code> in <a href="http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html#Tables">Gambit</a>.
</li></ul><ul><li>The procedure <code>hash-table-set-entries!</code> was suggested by the <a href="http://clhs.lisp.se/Body/f_pairli.htm">Common Lisp</a> function <code>pairlis</code>.
</li></ul><ul><li>The procedures <code>hash-table-unfold</code> and <code>hash-table-count</code> were suggested by <a href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI 1</a>.  
</li></ul><ul><li>The procedures <code>hash-table-accessor</code> and <code>hash-table-accessor/default</code> were loosely inspired by the finite functions of <a href="https://code.google.com/p/owl-lisp/wiki/OwlManual#Finite_Functions">Owl Lisp</a>.
</li></ul><ul><li>The procedures <code>hash-table=?</code>, <code>hash-table-map</code>, <code>hash-table-map-values</code>, and <code>hash-table-filter!</code> were suggested by <a href="http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/Data-Map-Strict.html">Haskell's Data.Map.Strict module</a>.
</li></ul><ul><li>The bimap procedures are based on the bimaps of Gauche and Java.
</li></ul><p>
The predicate <code>hash-table-empty?</code>, as well as the mutation procedures <code>hash-table-set-entries!</code>, <code>hash-table-replace!</code>, <code>hash-table-replace!/default</code>, <code>hash-table-map!</code>, <code>hash-table-intersection!</code>, and <code>hash-table-difference!</code>, were added for completeness. 
</p>
<p>
The native hash tables of <a href="http://web.mit.edu/scheme_v9.0.1/doc/mit-scheme-ref/Hash-Tables.html">MIT</a>,  <a href="http://www.gnu.org/software/guile/manual/html_node/Hash-Table-Reference.html">Guile</a>, <a href="http://sisc-scheme.org/manual/html/ch09.html#Hashtables">SISC</a>, <a href="http://www-sop.inria.fr/indes/fp/Bigloo/doc/bigloo-7.html#Hash-Tables">Bigloo</a>, <a href="http://s48.org/0.57/manual/s48manual_44.html">Scheme48</a>, <a href="http://www.cs.indiana.edu/scheme-repository/SCM/slib_2.html#SEC13">SLIB</a>, <a href="http://www.rscheme.org/rs/b/0.7.3.4/5/html/c2143.html">RScheme</a>, <a href="https://ccrma.stanford.edu/software/snd/snd/s7.html#hashtables">Scheme 7</a>, <a href="https://github.com/barak/scheme9/blob/master/lib/hash-table.scm">Scheme 9</a>, <a href="http://www.fifi.org/cgi-bin/info2www?(librep)Hash+Tables">Rep</a>, and <a href="https://code.google.com/p/femtolisp/wiki/APIReference">FemtoLisp</a> were also investigated, but no additional procedures were incorporated.
</p>
<h3 id="Pronunciation">Pronunciation</h3>
<p>
The slash in the names of some procedures can be pronounced "with".
</p>
<h3 id="Acknowledgements">Acknowledgements</h3>
<p>
Some of the language of this SRFI is copied from SRFI 69 with thanks to its author, Panu Kalliokoski.  However, he is not responsible for what I have done with it.  Thanks to Will Clinger for providing the sample implementation, and to Taylan Ulrich Bayırlı/Kammer for his spirited review.
</p>

<h1>Specification</h1>

<p>
All references to "executing in expected amortized constant time" presuppose that a satisfactory hash function is available.  Arbitrary or non-idempotent hash functions can make a hash of any implementation.
</p>
<p>
Hash tables are allowed to cache the results of calling the equality predicate and hash function, so programs cannot rely on the hash function being called exactly once for every primitive hash table operation: it may be called zero, one, or more times.
</p>
<p>
It is an error if the procedure argument of <code>hash-table-find</code>, <code>hash-table-count</code>, <code>hash-table-map</code>, <code>hash-table-map-values</code>, <code>hash-table-for-each</code>, <code>hash-table-map!</code>, <code>hash-table-collect</code>, or <code>hash-table-fold</code> mutates the hash table being walked.
</p>
<p>
It is an error to pass two hash tables that have different comparators or equality predicates to any of the procedures of this SRFI.
</p>
<p>
It is an error to mutate a key during or after its insertion into a hash table in such a way that the hash function of the table will return a different result when applied to that key.  In particular, this means
that mutating a key in a hash table based on <code>eq-comparator</code> or <code>eqv-comparator</code>, or the hash functions <code>eq?</code> or <code>eqv?</code>, is unproblematic, but mutating a key in a hash table based on <code>equal-comparator</code> or <code>equal?</code> is almost always an error.
</p>
<h3 id="Index">Index</h3>
<ul><li><a class="wiki" href="#Constructors">Constructors</a>: <code>make-hash-table</code>, <code>hash-table</code>, <code>hash-table-tabulate</code>, <code>hash-table-unfold</code>, <code>alist-&gt;hash-table</code>
</li></ul><ul><li><a class="wiki" href="#Hashfunctions">Hash functions</a>: <code>hash</code>, <code>string-hash</code>, <code>string-ci-hash</code>, <code>hash-by-identity</code>
</li></ul><ul><li><a class="wiki" href="#Predicates">Predicates</a>: <code>hash-table?</code>, <code>hash-table-contains?</code>, <code>hash-table-empty?</code>, <code>hash-table=?</code>, <code>hash-table-immutable?</code>
</li></ul><ul><li><a class="wiki" href="#Accessors">Accessors</a>: <code>hash-table-ref</code>, <code>hash-table-ref/default</code>
</li></ul><ul><li><a class="wiki" href="#Mutators">Mutators</a>: <code>hash-table-set!</code>, <code>hash-table-set-entries!</code>, <code>hash-table-delete!</code>, <code>hash-table-delete-keys!</code>, <code>hash-table-extend!</code>, <code>hash-table-extend!/default</code>, <code>hash-table-replace!</code>, <code>hash-table-replace!/default</code>, <code>hash-table-update!</code>, <code>hash-table-update!/default</code>, <code>hash-table-push!</code>, <code>hash-table-pop!</code>, <code>hash-table-clear!</code>
</li></ul><ul><li><a class="wiki" href="#Thewholehashtable">The whole hash table</a>: <code>hash-table-size</code>, <code>hash-table-keys</code>, <code>hash-table-values</code>, <code>hash-table-entries</code>, <code>hash-table-find</code>, <code>hash-table-count</code>, <code>hash-table-any</code>, <code>hash-table-every</code>
</li></ul><ul><li><a class="wiki" href="#Mappingandfolding">Mapping and folding</a>: <code>hash-table-map</code>, <code>hash-table-map-values</code>, <code>hash-table-for-each</code>, <code>hash-table-map!</code>, <code>hash-table-collect</code>, <code>hash-table-fold</code>, <code>hash-table-filter!</code>, <code>hash-table-remove!</code>
</li></ul><ul><li><a class="wiki" href="#Copyingandconversion">Copying and conversion</a>: <code>hash-table-copy</code>, <code>hash-table-&gt;alist</code>
</li></ul><ul><li><a class="wiki" href="#Hashtablesasfunctions">Hash tables as functions</a>: <code>hash-table-accessor</code>, <code>hash-table-accessor/default</code>
</li></ul><ul><li><a class="wiki" href="#Hashtablesassets">Hash tables as sets</a>: <code>hash-table-union!</code>, <code>hash-table-intersection!</code>, <code>hash-table-difference!</code>, <code>hash-table-xor!</code>
</li></ul><ul><li><a class="wiki" href="#Bimaps">Bimaps</a>: <code>make-bimap</code>, <code>bimap?</code>, <code>bimap-forward-hash-table</code>, <code>bimap-reverse-hash-table</code>, <code>bimap-contains?</code>, <code>bimap-contains-value?</code>, <code>bimap=?</code>, <code>bimap-ref</code>, <code>bimap-value-ref</code>, <code>bimap-ref/default</code>, <code>bimap-value-ref/default</code>, <code>bimap-copy</code>, <code>bimap-set!</code>, <code>bimap-set-entries!</code>, <code>bimap-delete!</code>, <code>bimap-delete-keys!</code>, <code>bimap-extend!</code>, <code>bimap-extend/default!</code>, <code>bimap-replace!</code>, <code>bimap-replace/default!</code>, <code>bimap-update!</code>, <code>bimap-update/default!</code>, <code>bimap-clear!</code>, <code>bimap-filter!</code>, <code>bimap-remove!</code>
</li></ul><h3 id="Constructors">Constructors</h3>
<p>
<code>(make-hash-table </code><em>comparator</em> [ <em>arg</em> ... ]<code>)</code>
</p>
<p><small>
<code>(make-hash-table </code><em>equality-predicate</em> [ <em>hash-function</em> ] [ <em>arg</em> ... ]<code>)</code>
</small></p>
<p>
Returns a newly allocated hash table whose equality predicate and hash function are extracted from <em>comparator</em>.  Alternatively, for backward compatibility with SRFI 69 the equality predicate and hash function can be passed as separate arguments; this usage is deprecated.  Note that SRFI 69 hash functions are specified to accept two arguments, the object to be hashed and a non-negative integer that bounds the hash code.  However, the hash functions passed to <code>make-hash-table</code> are not required to accept a second argument.
</p>
<p>
If an equality predicate rather than a comparator is provided, the ability to omit the <em>hash-function</em> argument is severely limited.  The implementation must provide hash functions appropriate for use with the predicates <code>eq?</code>, <code>eqv?</code>, <code>equal?</code>, <code>string=?</code>, and <code>string-ci=?</code>, and may extend this list.  But if any unknown equality predicate is provided without a hash function, an error should be signaled.
</p>
<p>
It is an error if the equality predicate does not accept two arguments and return a truth value.  It is also an error if the hash function does not accept one argument in the domain of the equality predicate and return a non-negative exact integer.  It is the programmer's responsibility to ensure that if two objects are the same in the sense of the equality predicate, then they  return the same value when passed to the hash function.  However, the converse is not required.
</p>
<p>
If the equality predicate, whether passed as part of a comparator or explicitly, is more fine-grained (in the sense of R7RS-small section 6.1) than <code>equal?</code>, the implementation is free — indeed, is encouraged — to ignore the programmer-specified hash function and use something implementation-dependent.  This allows the use of addresses as hashes, in which case the keys must be rehashed if they are moved by the garbage collector.
</p>
<p>
The meaning of any further arguments is implementation-dependent.  However, implementations which support the ability to specify the initial capacity of a hash table should interpret a non-negative exact integer as the specification of that capacity.  In addition, if the symbols <code>thread-safe</code>, <code>weak-keys</code> or  <code>weak-values</code> are present, implementations should create thread-safe hash tables, hash tables with weak keys, and hash tables with weak values respectively.  In an implementation which does not support these features, an error should be signaled if they are requested.  To avoid collision with the <em>hash-function</em> argument, none of these arguments can be procedures.
</p>
<p>
(R6RS <code>make-eq-hashtable</code>, <code>make-eqv-hashtable</code>, and <code>make-hashtable</code>; Common Lisp <code>make-hash-table</code>)
</p>
<p>
<code>(hash-table </code><em>comparator</em> ( <em>key value</em> ) ...<code>)</code>
</p>
<p>
Returns a newly allocated hash table, created as if by <code>make-hash-table</code> using <em>comparator</em>.  For each pair of arguments, an association is added to the new hash table with <em>key</em> as its key and <em>value</em> as its value.  If the implementation supports immutable hash tables, this procedure returns an immutable hash table.
</p>
<p>
<code>(hash-table-tabulate </code><em>comparator n proc</em><code>)</code>
</p>
<p>
Returns a newly allocated hash table, created as if by <code>make-hash-table</code> using <em>comparator</em>.  For each integer from 0 to <em>n</em> - 1, <em>proc</em> is invoked on it, returning two values.  The values are used as the key and value of an association added to the new hash table.  If the implementation supports immutable hash tables, this procedure returns an immutable hash table.
</p>
<p>
<code>(hash-table-unfold </code><em>stop? mapper successor seed comparator arg</em> ... ]<code>)</code>
</p>
<p>
Create a new hash table as if by <code>make-hash-table</code> using <em>comparator</em> and the <em>args</em>.  If the result of applying the predicate <em>stop?</em> to <em>seed</em> is true, return the hash table.  Otherwise, apply the procedure <em>mapper</em> to <em>seed</em>.  <em>Mapper</em> returns two values, which are inserted into the hash table as the key and the value respectively.  Then get a new seed by applying the procedure <em>successor</em> to <em>seed</em>, and repeat this algorithm.
</p>
<p>
<code>(alist-&gt;hash-table </code><em>alist comparator arg</em> ...<code>)</code>
</p>
<p>
<small><code>(alist-&gt;hash-table </code><em>alist equality-predicate</em> [ <em>hash-function</em> ] <em>arg</em> ...<code>)</code>
</small></p>
<p>
Returns a newly allocated hash-table as if by <code>make-hash-table</code> using <em>comparator</em> and the <em>args</em>.  It is then initialized from the associations of <em>alist</em>.  Associations earlier in the list take precedence over those that come later.  The second form is for compatibility with SRFI 69, and is deprecated.
</p>
<h3 id="Hashfunctions">Hash functions</h3>
<p>These functions are provided solely for compatibility with SRFI 69 and are deprecated.</p>
<p>
<small><code>(hash </code><em>obj</em><code>)</code>
</small></p>
<p>
The same as the hash function from SRFI 114's <code>equal-comparator</code> object.
</p>
<p><small><code>(string-hash </code><em>obj</em><code>)</code></small>
</p>
<p>
The same as the hash function from SRFI 114's <code>string-comparator</code> object.
</p>
<p><small><code>(string-ci-hash </code><em>obj</em><code>)</code></small>
</p>
<p>
The same as the hash function from SRFI 114's <code>string-ci-comparator</code> object.
</p> 
<p>
<small><code>(hash-by-identity </code><em>obj</em><code>)</code></small>
</p>
<p>
The same as the hash function from SRFI 114's <code>eq-comparator</code> object.
</p>
<h3 id="Predicates">Predicates</h3>
<p>
<code>(hash-table? </code><em>obj</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>obj</em> is a hash table, and <code>#f</code> otherwise.  (R6RS <code>hashtable?</code>; Common Lisp <code>hash-table-p</code>)
</p>
<p>
<code>(hash-table-contains? </code><em>hash-table key</em><code>)</code>
</p>
<small><p>
<code>(hash-table-exists? </code><em>hash-table key</em><code>)</code>
</p>
</small><p>
Returns <code>#t</code> if there is any association to <em>key</em> in <em>hash-table</em>, and <code>#f</code> otherwise.  Must execute in expected amortized constant time.  The <code>hash-table-exists</code> procedure is the same as <code>hash-table-contains</code>, is provided for backward compatibility with SRFI 69, and is deprecated.  (R6RS <code>hashtable-contains?</code>)
</p>
<p>
<code>(hash-table-empty? </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>hash-table</em> contains no associations, and <code>#f</code> otherwise.
</p>
<p>
<code>(hash-table=? </code><em>value-comparator hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>hash-table<sub>1</sub></em> and <em>hash-table<sub>2</sub></em> have the same keys (in the sense of their common equality predicate) and each key has the same value (in the sense of <em>value-comparator</em>), and <code>#f</code> otherwise.
</p>
<p>
<code>(hash-table-mutable? </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if the hash table is mutable.  implementations may or may not support immutable hash tables.  (R6RS <code>hashtable-mutable?</code>)
</p>
<h3 id="Accessors">Accessors</h3>
<p>
The following procedures, given a key, return the corresponding value.
</p>
<p>
<code>(hash-table-ref </code><em>hash-table key</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Extracts the value associated to <em>key</em> in <em>hash-table</em>, invokes the procedure <em>success</em> on it, and returns its result; if <em>success</em> is not provided, then the value itself is returned.  If <em>key</em> is not contained in <em>hash-table</em> and <em>failure</em> is supplied, then <em>failure</em> is invoked on no arguments and its result is returned.  Otherwise, it is an error.  Must execute in expected amortized constant time, not counting the time to call the procedures.  SRFI 69 does not support the <em>success</em> procedure.
</p>
<p>
<code>(hash-table-ref/default </code><em>hash-table key default</em><code>)</code>
</p>
<p>
Semantically equivalent to, but may be more efficient than, the following code:
</p>
<blockquote>
<p>
<code>(hash-table-ref </code><em>hash-table key</em> <code>(lambda () </code><em>default</em><code>))</code>
</p>
</blockquote>
<p>
(R6RS <code>hashtable-ref</code>; Common Lisp <code>gethash</code>)
</p>
<h3 id="Mutators">Mutators</h3>
<p>
The following procedures alter the associations in a hash table either unconditionally, or conditionally on the presence or absence of a specified key.  It is an error to add an association to a hash table whose key does not satisfy the type test predicate of the comparator used to create the hash table.
</p>
<p>
<code>(hash-table-set! </code><em>hash-table</em> ( <em>key value</em> ) ...<code>)</code>
</p>
<p>
Repeatedly mutates <em>hash-table</em>, creating new associations in <em>hash-table</em> that associates each <em>key</em> with the <em>value</em> that follows it.  If there is a previous association for <em>key</em>, it is deleted.  It is an error if the type check procedure of the comparator of <em>hash-table</em>, when invoked on <em>key</em>, does not return <code>#t</code>. Likewise, it is an error if <em>key</em> is not a valid argument to the equality predicate of <em>hash-table</em>.  Returns an unspecified value.  Must execute in expected amortized constant time per key.  SRFI 69, R6RS <code>hashtable-set!</code> and Common Lisp <code>(setf gethash)</code> do not handle multiple associations.
</p>
<p>
<code>(hash-table-set-entries! </code><em>hash-table keys-list values-list</em><code>)</code>
</p>
<p>
Repeatedly mutates <em>hash-table</em>, setting each element of <em>keys-list</em> to the corresponding element of <em>values-list</em> in the order in which they are specified.  Excess keys or values are ignored.
</p>
<p>
<code>(hash-table-delete! </code><em>hash-table key</em> ...<code>)</code>
</p>
<p>
Deletes any association to each <em>key</em> in <em>hash-table</em> and returns the number of keys that had associations.  Must execute in expected amortized constant time per key.  SRFI 69, R6RS <code>hashtable-delete!</code>, and Common Lisp <code>remhash</code> do not handle multiple associations.
</p>
<p>
<code>(hash-table-delete-keys! </code><em>hash-table keys-list</em><code>)</code>
</p>
<p>
Semantically equivalent to, but may be more efficient than, the following code:
</p>
<blockquote>
<p>
<code>(for-each (lambda (key) (hash-table-delete! </code><em>hash-table</em><code> key)) </code><em>keys-list</em><code>)</code>
</p>
</blockquote>
<p>
<code>(hash-table-extend! </code><em>hash-table key</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Effectively invokes <code>hash-table-ref</code> with the given arguments and returns what it returns.  If <em>key</em> was not found in <em>hash-table</em>, its value is set to the result being returned.  Must execute in expected amortized constant time.
</p>
<p>
<code>(hash-table-extend!/default </code><em>hash-table key default</em><code>)</code>
</p>
<p>
Effectively invokes <code>hash-table-ref/default</code> with the given arguments and returns what it returns.  If <em>key</em> was not found in <em>hash-table</em>, its association is set to the result being returned.  Must execute in expected amortized constant time.
</p>
<p>
<code>(hash-table-replace! </code><em>hash-table key</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Effectively invokes <code>hash-table-ref</code> with the given arguments and returns what it returns.  If <em>key</em> was found in <em>hash-table</em>, its value is set to the result being returned.  Must execute in expected amortized constant time.
</p>
<p>
<code>(hash-table-replace!/default </code><em>hash-table key</em> <em>default</em><code>)</code>
</p>
<p>
Effectively invokes <code>hash-table-ref/default</code> with the given arguments and returns what it returns.  If <em>key</em> was found in <em>hash-table</em>, its value is set to the result being returned.  Must execute in expected amortized constant time.
</p>
<p>
<code>(hash-table-update! </code><em>hash-table key updater</em> [ <em>failure</em> [ <em>success ] ]<code>)</code>
</em></p>
<p>
Semantically equivalent to, but may be more efficient than, the following code:
</p>
<blockquote>
<p>
<code>(hash-table-set! </code><em>hash-table key</em><code> (</code><em>updater</em> <code>(hash-table-ref </code><em>hash-table key failure success</em><code>)))</code>
</p>
</blockquote>
<p>
Must execute in expected amortized constant time.  Returns an unspecified value.  (SRFI 69 and R6RS <code>hashtable-update!</code> do not support the <em>success</em> procedure)
</p>
<p>
<code>(hash-table-update!/default </code><em>hash-table key updater default</em><code>)</code>
</p>
<p>
Semantically equivalent to, but may be more efficient than, the following code:
</p>
<blockquote>
<p>
<code>(hash-table-set! </code><em>hash-table key</em><code> (</code><em>updater</em> <code>(hash-table-ref/default </code><em>hash-table key default</em><code>)))</code>
</p>
</blockquote>
<p>
Must execute in expected amortized constant time.  Returns an unspecified value.
</p>
<p>
<code>(hash-table-push! </code><em>hash-table key value failure</em><code>)</code>
</p>
<p>
If an association with <em>key</em> is found in <em>hash-table</em>, then update the value associated with <em>key</em> to the result of invoking <code>cons</code> on <em>value</em> and  the original value.  If the key is not found, a new association between <em>key</em> and the result of invoking the thunk <em>failure</em> is added to <em>hash-table</em>.  The return value of <code>hash-table-push!</code> is unspecified.  It is an error if an existing value is not a pair.
</p>
<p>
<code>(hash-table-pop! </code><em>hash-table key failure</em><code>)</code>
</p>
<p>
If an association with <em>key</em> is found in <em>hash-table</em>, then return the car of the value, and update the value to its own cdr.  If the value is not found, then the result of invoking the thunk <em>failure</em> is returned.  It is an error if the existing value is not a pair.
</p>
<p>
<code>(hash-table-clear! </code><em>hash-table</em><code>)</code>
</p>
<p>
Delete all the associations from <em>hash-table</em>.  (R6RS <code>hashtable-clear!</code>; Common Lisp <code>clrhash</code>)
</p>
<h3 id="Thewholehashtable">The whole hash table</h3>
<p>
These procedures process the associations of the hash table in an unspecified order.
</p>
<p>
<code>(hash-table-size </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns the number of associations in <em>hash-table</em> as an exact integer.  Should execute in constant time.  (R6RS <code>hashtable-size</code>; Common Lisp <code>hash-table-count</code>.)
</p>
<p>
<code>(hash-table-find </code><em>hash-table proc failure</em><code>)</code>
</p>
<p>
For each association of <em>hash-table</em>, invoke <em>proc</em> on its key and value.   If <em>proc</em> returns true, then <code>hash-table-find</code> returns what <em>proc</em> returns.  If all the calls to <em>proc</em> return <code>#f</code>, return the result of invoking the thunk <em>failure</em>.
</p>
<p>
<code>(hash-table-count </code><em>hash-table pred</em><code>)</code>
</p>
<p>
For each association of <em>hash-table</em>, invoke <em>pred</em> on its key and value.  Return the number of calls to <em>pred</em> which returned true.
</p>
<p>
<code>(hash-table-any </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for as many associations in <em>hash-table</em> as necessary with two arguments, the key and the value of the association.  If any invocation of <em>proc</em> returns true, <code>hash-table-any</code> immediately returns whatever that invocation returns; otherwise it returns <code>#f</code>.
</p>
<p>
<code>(hash-table-every </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for as many associations in <em>hash-table</em> as necessary with two arguments, the key and the value of the association.  If any invocation of <em>proc</em> returns false, <code>hash-table-every</code> immediately returns <code>#f</code>; otherwise it returns <code>#t</code>.
</p>
<h3 id="Mappingandfolding">Mapping and folding</h3>
<p>
These procedures process the associations of the hash table in an unspecified order.
</p>
<p>
<code>(hash-table-map </code><em>proc comparator merger hash-table</em><code>)</code>
</p>
<p>
Returns a newly allocated hash table as if by <code>(make-hash-table </code><em>comparator</em><code>)</code>.  Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments: the key of the association and the value of the association.  The two values returned by <em>proc</em> are inserted into the new hash table as a key and value.
</p>
<p>
When the key being added is equal (in the sense of <em>comparator</em>) to a key already inserted in the new hash table, the procedure <em>merger</em> is called with arguments <em>oldkey oldvalue newkey newvalue</em> and returns the key to be associated with the new value.
</p>
<p>
<code>(hash-table-map-values </code><em>proc comparator hash-table</em><code>)</code>
</p>
<p>
Returns a newly allocated hash table as if by <code>(make-hash-table </code><em>comparator</em><code>)</code>.  Calls <em>proc</em> for every association in <em>hash-table</em> with the value of the association.  The key of the association and the result of invoking <em>proc</em> are entered into the new hash table.
</p>
<p>
<code>(hash-table-for-each </code><em>proc hash-table</em><code>)</code>
</p>
<p>
<small><code>(hash-table-walk </code><em>hash-table proc</em><code>)</code>
</small></p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments: the key of the association and the value of the association.  The value returned by <em>proc</em> is discarded.  Returns an unspecified value.  The <code>hash-table-walk</code> procedure is equivalent to <code>hash-table-for-each</code> with the arguments reversed, is provided for backward compatibility with SRFI 69, and is deprecated.  (Common Lisp <code>maphash</code>)
</p>
<p>
<code>(hash-table-map! </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments: the key of the association and the value of the association.  The value returned by <em>proc</em> is used to update the value of the association.   Returns an unspecified value.
</p>
<p>
<code>(hash-table-collect </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments: the key of the association and the value of the association.  The values returned by the invocations of <em>proc</em> are accumulated into a list, which is returned.  
</p>
<p>
<code>(hash-table-fold </code><em>proc seed hash-table</em><code>)</code>
</p>
<p>
<small><code>(hash-table-fold </code><em>hash-table proc seed</em><code>)</code>
</small></p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with three arguments: the key of the association, the value of the association, and an accumulated value <em>val</em>.  <em>Val</em> is <em>seed</em> for the first invocation of <em>procedure</em>, and for subsequent invocations of <em>proc</em>, the returned value of the previous invocation.  The value returned by <code>hash-table-fold</code> is the return value of the last invocation of <em>proc</em>.  The order of arguments with <em>hash-table</em> as the first argument is provided for SRFI 69 compatibility, and is deprecated.
</p>
<p>
<code>(hash-table-filter! </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments, the key and the value of the association, and removes all associations from <em>hash-table</em> for which <em>proc</em> returns false.  Returns an unspecified value.
</p>
<p>
<code>(hash-table-remove! </code><em>proc hash-table</em><code>)</code>
</p>
<p>
Calls <em>proc</em> for every association in <em>hash-table</em> with two arguments, the key and the value of the association, and removes all associations from <em>hash-table</em> for which <em>proc</em> returns true.  Returns an unspecified value.
</p> hash-table
<h3 id="Copyingandconversion">Copying and conversion</h3>
<p>
<code>(hash-table-copy </code><em>hash-table</em> [ <em>mutable?</em> ]<code>)</code>
</p>
<p>
Returns a newly allocated hash table with the same properties and associations as <em>hash-table</em>. If the second argument is present and is true, the new hash table is mutable.  Otherwise it is immutable provided that the implementation supports immutable hash tables.  SRFI 69 <code>hash-table-copy</code> does not support a second argument.  (R6RS <code>hashtable-copy</code>)
</p>
<p>
<code>(hash-table-keys </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns a newly allocated list of all the keys in <em>hash-table</em>. R6RS <code>hashtable-keys</code> returns a vector.
</p>
<p>
<code>(hash-table-values </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns a newly allocated list of all the keys in <em>hash-table</em>.
</p>
<p>
<code>(hash-table-entries </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns two values, a newly allocated list of all the keys in <em>hash-table</em>and a newly allocated list of all the values in <em>hash-table</em> in the corresponding order.  R6RS <code>hash-table-entries</code> returns vectors.)
</p>
<p>
<code>(hash-table-&gt;alist </code><em>hash-table</em><code>)</code>
</p>
<p>
Returns an alist with the same associations as <em>hash-table</em> in an unspecified order.  (SRFI 69)
</p>
<h3 id="Hashtablesasfunctions">Hash tables as functions</h3>
<p>
The following procedures provide functions that have mutable behavior based on hash tables.  In this way, for example, lists can be processed by <code>map</code> using the procedure returned from a hash table by <code>hash-table-accessor</code>.
</p>
<p>
<code>(hash-table-accessor </code><em>hash-table</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Curried version of <code>hash-table-ref</code>.  Returns a procedure of one argument, a key, which returns what <code>hash-table-ref</code> returns when invoked with the passed arguments.
</p>
<p>
<code>(hash-table-accessor/default </code><em>hash-table default</em><code>)</code>
</p>
<p>
Curried version of <code>hash-table-ref/default</code>.  Returns a procedure of one argument, a key, which returns what <code>hash-table-ref/default</code> returns when invoked with the passed arguments.
</p>
<h3 id="Hashtablesassets">Hash tables as sets</h3>
<p>
<code>(hash-table-union! </code><em>hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</p>
<p>
<small><code>(hash-table-merge! </code><em>hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</small></p>
<p>
Adds the associations of <em>hash-table<sub>2</sub></em> to <em>hash-table<sub>1</sub></em> and returns <em>hash-table<sub>1</sub></em>.  If a key appears in both hash tables, its value is set to the value appearing in <em>hash-table<sub>1</sub></em>.  Returns <em>hash-table<sub>1</sub></em>.  The <code>hash-table-merge!</code> procedure is the same as <code>hash-table-union!</code>, is provided for compatibility with SRFI 69, and is deprecated.
</p>
<p>
<code>(hash-table-intersection! </code><em>hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</p>
<p>
Deletes the associations from <em>hash-table<sub>1</sub></em> which don't also appear in <em>hash-table<sub>2</sub></em> and returns <em>hash-table<sub>1</sub></em>.
</p>
<p>
<code>(hash-table-difference! </code><em>hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</p>
<p>
Deletes the associations of <em>hash-table<sub>1</sub></em> whose keys are also present in <em>hash-table<sub>2</sub></em> and returns <em>hash-table<sub>1</sub></em>.
</p>
<p>
<code>(hash-table-xor! </code><em>hash-table<sub>1</sub> hash-table<sub>2</sub></em><code>)</code>
</p>
<p>
Deletes the associations of <em>hash-table<sub>1</sub></em> whose keys are also present in <em>hash-table<sub>2</sub></em>, and then adds the associations of <em>hash-table<sub>2</sub></em> whose keys are not present in 'hash-table<sub>1</sub><em> to 'hash-table<sub>1</sub></em>.  Returns <em>hash-table<sub>1</sub></em>.
</p>
<h2 id="Bimaps">Bimaps</h2>
<p>
A bimap is built by starting with a hash table which represents the forward mapping from keys to values; it is an error if the values are not unique.  A second hash table is constructed and populated with the reverse mapping.  It is possible to retrieve either underlying hash table for read-only operations, but it is an error to mutate them, so bimap mutation procedures are provided.
</p>
<p>
<code>(make-bimap </code><em>hash-table comparator arg</em> ...<code>)</code>
</p>
<p>
Returns a newly allocated bimap whose forward hash table is <em>hash-table</em> and whose reverse hash table is newly allocated using <em>comparator</em> and any <em>args</em>.  It is an error if any value in <em>hash-table</em> is not unique in the sense of <em>comparator</em>.  It is an error to mutate <em>hash-table</em> after this procedure returns, as it shares structure with the bimap.
</p>
<p>
<code>(bimap? </code><em>obj</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>obj</em> is a bimap and <code>#f</code> otherwise.
</p>
<p>
<code>(bimap-forward-hash-table </code><em>bimap</em><code>)</code>
</p>
<p>
Returns the original hash table passed to the bimap.  It is an error to mutate this hash table.
</p>
<p>
<code>(bimap-reverse-hash-table </code><em>bimap</em><code>)</code>
</p>
<p>
Returns the reverse hash table created by <code>make-bimap</code>.  It is an error to mutate this hash table.
</p>
<p>
<code>(bimap-contains? </code><em>bimap key</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>key</em> is contained in one of the associations of the bimap, and <code>#f</code> otherwise.
</p>
<p>
<code>(bimap-contains-value? </code><em>bimap value</em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>value</em> is contained in one of the associations of the bimap, and <code>#f</code> otherwise.
</p>
<p>
<code>(bimap=? </code><em>bimap<sub>1</sub> bimap<sub>2</sub></em><code>)</code>
</p>
<p>
Returns <code>#t</code> if <em>bimap<sub>1</sub></em> and <em>bimap<sub>2</sub></em> contain the same key-value associations.  Two associations <em>key<sub>1</sub>/value<sub>1</sub></em> and <em>key<sub>2</sub>/value<sub>2</sub></em> are the same if and only if the reverse hash tables of both <em>bimap<sub>1</sub></em> and <em>bimap<sub>2</sub></em> map <em>value<sub>1</sub>' and </em>value<sub>2</sub><em> to keys that are the same in the sense of the equivalence procedures of both tables.  Returns <code>#f</code> otherwise.
</em></p>
<p>
<code>(bimap-ref </code><em>bimap key</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Returns what <code>(hash-table-ref (bimap-forward-hash-table </code><em>bimap</em><code>) </code><em>key failure success</em><code>)</code> returns.
</p>
<p>
<code>(bimap-ref/default </code><em>bimap key default</em><code>)</code>
</p>
<p>
Returns what <code>(hash-table-ref (bimap-forward-hash-table </code><em>bimap</em><code>) </code><em>key default</em><code>)</code> returns.
</p>
<p>
<code>(bimap-value-ref </code><em>bimap value</em> [ <em>failure</em> [ <em>success</em> ] ]<code>)</code>
</p>
<p>
Returns what <code>(hash-table-ref (bimap-reverse-hash-table </code><em>bimap</em><code>) </code><em>value failure success</em><code>)</code> returns.
</p>
<p>
<code>(bimap-value-ref/default </code><em>bimap value default</em><code>)</code>
</p>
<p>
Returns what <code>(hash-table-ref (bimap-reverse-hash-table </code><em>bimap</em><code>) </code><em>value default</em><code>)</code> returns.
</p>
<p>
<code>(bimap-copy </code><em>bimap</em> [ <em>immutable?</em> ]<code>)</code>
</p>
<p>
Returns a newly allocated bimap with the same properties and associations as <em>bimap</em>. If the second argument is present and is true, the new bimap is mutable.  Otherwise it is made from immutable hash tables and itself immutable, provided the implementation supports immutable hash tables.
</p>
<p>
The mutation procedures <code>bimap-set!</code>, <code>bimap-set-entries!</code>, <code>bimap-delete!</code>, <code>bimap-delete-keys!</code>, <code>bimap-extend!</code>, <code>bimap-extend/default!</code>, <code>bimap-replace!</code>, <code>bimap-replace/default!</code>, <code>bimap-update!</code>, <code>bimap-update/default!</code>, <code>bimap-clear!</code>, <code>bimap-filter!</code>, and <code>bimap-remove!</code> have the same behavior as their hash table analogues, mutating both hash tables appropriately.
</p>


<h1>Implementation</h1>

<p>
The <a href="https://github.com/larcenists/larceny/tree/master/tools/R7RS/in-progress/hash">current sample implementation</a> is easily layered over any hash table implementation that supports either SRFI 69 or R6RS.  The sample implementation is built directly on top of <code>(r6rs hashtables)</code> (available in the same repository or at <a href="http://snow-fort.org/pkg">http://snow-fort.org/pkg</a>), whose portable implementation uses <code>(rnrs hashtables)</code> if that library is available, or SRFI 69 if that library is available, or a slightly improved version of the SRFI 69 sample implementation if no better alternative is available.
</p>
<p>
The procedures in this SRFI are currently in the <code>(in-progress hash tables)</code> and <code>(in-progress hash bimaps)</code> libraries.  This will change.
</p>
<p>
There is also an <a href="https://github.com/larcenists/larceny/blob/master/lib/SRFI/srfi-69.sch">implementation of SRFI 69</a> on top of the <code>(rnrs hashtables)</code> library of R6RS, which shows how to construct an implementation of SRFI 69 that would be fully compatible with the sample implementation of this SRFI.
</p>
<p>
The hash tables specified here are mostly compatible with hash tables as specified by SRFI 69, but there will certainly be conflicts when a library or program imports both the library specified here and an implementation of SRFI 69.  It should be possible to construct an implementation of SRFI 69 that does not conflict with the sample implementation of this SRFI or with <code>(r6rs hashtables)</code>, but all non-conflicting implementations of SRFI 69 must:
</p>
<ul><li>extend the <code>make-hash-table</code> and <code>alist-&gt;hash-table</code> procedures to accommodate their more general arguments as specified by this SRFI
</li><li>extend the <code>hash-table-fold</code> procedure to accept arguments in the order specified here as well as in the order specified by SRFI 69
</li><li>take care never to call a hash function with more than one argument
</li></ul><p>
As of this writing, there are no such fully compatible implementations of SRFI 69.
</p>
<p>The sample implementation never calls any hash function with two arguments.</p>
<p>
The originally intention was to make it possible to implement this SRFI on top of all the native hash table systems mentioned in <a class="wiki" href="#Sources">Sources</a> above as well.  However, this turned out not to be practical for the following reasons:
</p>
<ul><li>Gauche does not support arbitrary equality predicates, only <code>eq?</code>, <code>eqv?</code>, <code>equal?</code>, and <code>string=?</code>.
</li></ul><ul><li>S7 does not support arbitrary equality predicates: the implementation chooses a predicate based on the nature of the keys.
</li></ul><ul><li>SISC, Scheme48/scsh, RScheme, Scheme 9, and Rep do not document any procedure that copies a hash table, nor any way of inspecting it to determine its equality predicates and hash functions so that it can be re-created.
</li></ul><ul><li>SLIB hash tables are vectors, not disjoint objects.
</li></ul><ul><li>FemtoLisp supports only <code>equal?</code> as the equality predicate.
</li></ul><p>
Native Guile hash tables are a special case.  The equivalents of <code>hash-table-ref/default</code>, <code>hash-table-set!</code>, and <code>hash-table-delete</code> require the equality predicate and hash function to be passed to them explicitly (although there are utility functions for <code>eq?</code>, <code>eqv?</code>, and <code>equal?</code> hash tables).  Consequently, hash tables corresponding to this SRFI would have to be records containing a Guile hash table, an equality predicate, and a hash function, which means they could not interoperate directly with native Guile hash tables.
</p>

<h1>Copyright</h1>
Copyright (C) John Cowan (2015).
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
</p><p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
</p><p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

    </p><hr />
    <address>Editor: <a href="mailto:srfi-editors at srfi dot schemers dot org">Arthur A. Gleckler</a></address>
<!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
<!-- hhmts start -->
Last modified: Sun Aug  6 20:09:00 EDT 2015
<!-- hhmts end -->
</body></html>
